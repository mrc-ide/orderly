##' Find, and delete, file that were generated by running a report.
##' Until you're comfortable with what this will do, you are strongly
##' recommended to run `orderly_cleanup_status` first to see what will
##' be deleted.
##'
##' After file deletion, we look through and remove all empty
##' directories; orderly2 has similar semantics here to git where
##' directories are never directly tracked.
##'
##' For recent `gert` (not yet on CRAN) we will ask git if files are
##' ignored; if ignored then they are good candidates for deletion! We
##' encourage you to keep a per-report `.gitignore` that lists files
##' that will copy into the source directory, and then we can use that
##' same information to clean up these files after generation.
##' Importantly, even if a file matches an ignore rule but has been
##' committed to your repository, it will no longer match the ignore
##' rule.
##'
##' @section Notes for user of orderly1:
##'
##' In orderly1 this function has quite different semantics, because
##'   the full set of possible files is always knowable from the yaml
##'   file. So there, we start from the point of view of the list of
##'   files then compare that with the directory.
##'
##' @title Clean up source directory
##'
##' @param name Name of the report directory to clean (i.e., we look
##'   at `src/<name>` relative to your orderly root
##'
##' @inheritParams orderly_run
##'
##' @return An (currently unstable) object of class
##'   `orderly_cleanup_status` within which the element `delete`
##'   indicates files that would be deleted (for
##'   `orderly_cleanup_status`) or that were deleted (for
##'   `orderly_cleanup`)
##'
##' @author export
orderly_cleanup <- function(name = NULL, root = NULL, locate = TRUE) {
  status <- orderly_cleanup_status(name, root, locate)
  if (length(status$delete) > 0) {
    withr::with_dir(status$path, fs::file_delete(status$delete))
  }
  delete_empty_directories(status$path)
  invisible(status)
}


##' @export
##' @rdname orderly_cleanup
orderly_cleanup_status <- function(name = NULL, root = NULL, locate = TRUE) {
  p <- get_active_packet()
  is_active <- !is.null(p)
  if (is_active) {
    cli::cli_abort(
      "Don't call 'orderly2::orderly_cleanup_status()' from a running packet",
      i = "The orderly_cleanup* functions are for interactive use only")
  }

  if (is.null(name)) {
    path <- getwd()
    root <- detect_orderly_interactive_path(path)$path
    name <- basename(path)
  } else {
    root <- orderly_root(root, locate)
    validate_orderly_directory(name, root, environment())
    path <- file.path(root$path, "src", name)
    root <- root$path
  }

  info <- orderly_read(path)
  files <- withr::with_dir(
    path,
    dir(all.files = TRUE, recursive = TRUE, no.. = TRUE))

  ## Slightly tricky construction here as we need to match all files
  ## that are present as directory entries; this is explicit only for
  ## dependencies, but we need to work it out ourselves for the rest.
  matches_path <- function(x, path, add_slash = TRUE) {
    path_dir <- if (add_slash) with_trailing_slash(path) else path
    x %in% path |
      row_any(vapply(path_dir, function(p) string_starts_with(p, x),
                     logical(length(x))))
  }
  nms_resource <- info$resources
  nms_artefact <- unlist(lapply(info$artefacts, "[[", "files"))
  nms_dependency <- unlist(lapply(info$dependency, function(x) names(x$use)))
  nms_global_resource <- names(info$global_resource)

  role <- cbind(orderly = files == "orderly.R",
                resource = matches_path(files, nms_resource),
                global_resource = matches_path(files, nms_global_resource),
                dependency = matches_path(files, nms_dependency, FALSE),
                artefact = matches_path(files, nms_artefact))
  rownames(role) <- files

  v_source <- c("orderly", "resource")
  v_derived <- c("global_resource", "dependency", "artefact")

  is_source <- row_any(role[, v_source, drop = FALSE])
  is_derived <- !is_source & row_any(role[, v_derived, drop = FALSE])
  is_ignored <- path_is_git_ignored(file.path("src", name, files), path)
  status <- cbind(source = is_source,
                  derived = is_derived,
                  ignored = is_ignored)
  rownames(status) <- files

  to_delete <- (is_derived | (!is.na(is_ignored) & is_ignored)) & !is_source
  delete <- files[to_delete]

  structure(list(name = name,
                 root = root,
                 path = path,
                 role = role,
                 status = status,
                 delete = delete),
            class = "orderly_cleanup_status")
}
