% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run.R
\name{orderly_run}
\alias{orderly_run}
\title{Run a report}
\usage{
orderly_run(
  name,
  parameters = NULL,
  envir = NULL,
  logging_console = NULL,
  logging_threshold = NULL,
  search_options = NULL,
  root = NULL,
  locate = TRUE
)
}
\arguments{
\item{name}{Name of the report to run}

\item{parameters}{Parameters passed to the report. A named list of
parameters declared in the \code{orderly.yml}.  Each parameter
must be a scalar character, numeric, integer or logical.}

\item{envir}{The environment that will be used to evaluate the
report script; by default we use the global environment, which
may not always be what is wanted.}

\item{logging_console}{Optional logical to control printing logs
to the console, overriding any default configuration set at the
root.}

\item{logging_threshold}{Optional logging threshold to control the
amount of detail in logs printed during running, overriding any
default configuration set at the root. If given, must be one of
\code{info}, \code{debug} or \code{trace} (in increasing order of
verbosity). Practically this has no effect at present as we've
not added any fine-grained logging.}

\item{search_options}{Optional control over locations, when used
with \link{orderly_dependency}; converted into a
\link{orderly_search_options} object, see Details.}

\item{root}{The path to the root directory, or \code{NULL} (the
default) to search for one from the current working directory if
\code{locate} is \code{TRUE}. This function \strong{does} require that the
directory is configured for orderly, and not just outpack (see
\link{orderly_init} for details).}

\item{locate}{Logical, indicating if the configuration should be
searched for.  If \code{TRUE} and \code{config} is not given,
then orderly looks in the working directory and up through its
parents until it finds an \code{.outpack} directory}
}
\value{
The id of the created report (a string)
}
\description{
Run a report.  This will create a new directory in
\verb{drafts/<reportname>}, copy your declared resources there, run
your script and check that all expected artefacts were created.
}
\section{Locations used in dependency resolution}{


If your packet depends on other packets, you will want to control
the locations that are used to find appropriate packets. The
control for this is passed through this function and \emph{not} as an
argument to \link{orderly_dependency} because this is a
property of the way that a packet is created and not of a packet
itself; importantly different users may have different names for
their locations so it makes little sense to encode the location
name into the source code. Alternatively, you want to use
different locations in different contexts (initial development
where you want to include local copies packets as possible
dependencies vs resolving dependencies only as they would be
resolved on one of your locations!

Similarly, you might want to include packets that are known by
other locations but are not currently downloaded onto this
machine - pulling these packets in could take anything from
seconds to hours depending on their size and the speed of your
network connection (but \emph{not} pulling in the packets could mean
that your packet fails to run).

To allow for control over this you can pass in an argument
\code{search_options}, which is a \link{orderly_search_options}
object, and allows control over the names of the locations to
use, whether metadata should be refreshed before we pull
anything and if packets that are not currently downloaded should
be considered candidates.

This has no effect when running interactively, in which case you
can specify the search options (root specific) with
\link{orderly_interactive_set_search_options}
}

\section{Which packets might be selected from locations?}{


The \code{search_options} argument controls where outpack searches for
packets with the given query and if anything might be moved over
the network (or from one outpack archive to another). By default
everything is resolved locally only; that is we can only depend
on packets that are unpacked within our current archive.  If you
pass a \code{search_options} argument that contains \code{allow_remote = TRUE} (see \link{orderly_search_options} then packets
that are known anywhere are candidates for using as dependencies
and \emph{if needed} we will pull the resolved files from a remote
location. Note that even if the packet is not locally present
this might not be needed - if you have the same content anywhere
else in an unpacked packet we will reuse the same content
without re-fetching.

If \code{pull_metadata = TRUE}, then we will refresh location metadata
before pulling, and the \code{location} argument controls which
locations are pulled from.
}

\section{Equivalence to the old \code{use_draft} option}{


The above location handling generalises orderly (v1)'s old
\code{use_draft} option, in terms of the \code{location} argument to
orderly2::orderly_search_options`:
\itemize{
\item \code{use_draft = TRUE} is \code{location = "local"}
\item \code{use_draft = FALSE} is \code{location = c(...)} where you should provide
all locations \emph{except} local
(\code{setdiff(orderly2::orderly_location_list(), "local")})
\item \code{use_draft = "newer"} is \code{location = NULL}
}

(this last option was the one most people preferred so is the new
default behaviour). In addition, you could resolve dependencies
as they currently exist on production right now with the options:

\if{html}{\out{<div class="sourceCode">}}\preformatted{location = "production", pull_metadata = TRUE, require_unpacked = FALSE
}\if{html}{\out{</div>}}

which updates your current metadata from production, then runs
queries against only packets known on that remote, then depends
on them even if you don't (yet) have them locally.  This
functionality was never available in orderly version 1, though
we had intended to support it.
}

\examples{
path <- withr::local_tempfile()
fs::dir_copy(system.file("example", package = "orderly2"), path)
orderly2::orderly_init(path)
orderly2::orderly_run("data", root = path)

# After running, a finished packet appears in the archive:
fs::dir_tree(path)

# and we can query the metadata
orderly2::orderly_metadata_extract(name = "data", root = path)
}
