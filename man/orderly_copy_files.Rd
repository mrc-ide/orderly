% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/outpack_helpers.R
\name{orderly_copy_files}
\alias{orderly_copy_files}
\title{Copy files from a packet}
\usage{
orderly_copy_files(
  id,
  files,
  dest,
  allow_remote = FALSE,
  overwrite = TRUE,
  envir = parent.frame(),
  root = NULL,
  locate = TRUE
)
}
\arguments{
\item{id}{Id of the packet to copy from (will become a query, see
mrc-4418)}

\item{files}{Files to copy from the other packet. This can be (1)
a character vector, in which case files are copied over without
changing their names, (2) a \strong{named} character vector, in which
case the name will be used as the destination name, or (3) a
\link{data.frame} (including \code{tbl_df}, or \code{data.frame} objects)
containing columns \code{from} and \code{to}, in which case the files
\code{from} will be copied with names \code{to}.

In all cases, if you want to import a directory of files from a
packet, you must refer to the source with a trailing slash
(e.g., \code{c(here = "there/")}), which will create the local
directory \code{here/...} with files from the upstream packet
directory \verb{there/}. If you omit the slash then an error will be
thrown suggesting that you add a slash if this is what you
intended.

You can use a limited form of string interpolation in the names of
this argument; using \verb{$\{variable\}} will pick up values from
\code{envir} and substitute them into your string.  This is similar
to the interpolation you might be familiar with from
\code{glue::glue} or similar, but much simpler with no concatenation
or other fancy features supported.

Note that there is an unfortunate, but (to us) avoidable
inconsistency here; interpolation of values from your
environment in the query is done by using \code{environment:x} and in
the destination filename by doing \verb{$\{x\}}.}

\item{dest}{The directory to copy into}

\item{allow_remote}{Logical, indicating if we should attempt to
retrieve the file from any remote location if it cannot be found
locally. If the file is large, this may take some time depending
on the speed of the connection. If you use a file store, note
that this does add the downloaded file into your file store,
though associated with no packet so that it is subject to
garbage collection (once we write support for that).}

\item{overwrite}{Overwrite files at the destination; this is
typically what you want, but set to \code{FALSE} if you would prefer
that an error be thrown if the destination file already exists.}

\item{envir}{An environment into which string interpolation may
happen (see the \code{files} argument for details on the string
interpolation).  The default here is to use the calling
environment, which is typically reasonable, but may need
changing in programmatic use.}

\item{root}{The path to the root directory, or \code{NULL} (the
default) to search for one from the current working directory if
\code{locate} is \code{TRUE}. This function does not require that the
directory is configured for orderly, and can be any \code{outpack}
root (see \link{orderly_init} for details).}

\item{locate}{Logical, indicating if the root should be searched
for.  If \code{TRUE}, then we looks in the directory given for \code{root}
(or the working directory if \code{NULL}) and then up through its
parents until it finds an \code{.outpack} directory or
\code{orderly_config.yml}}
}
\value{
Nothing, invisibly. Primarily called for its side effect
of copying files from a packet into the directory \code{dest}
}
\description{
Copy files from a packet to anywhere. Similar to
\link{orderly_dependency} except that this is not used in an
active packet context. You can use this function to pull files
from an outpack root to a directory outside of the control of
outpack, for example.
}
\details{
There are different ways that this might fail (or recover from
failure):
\itemize{
\item if \code{id} is not known in the metadata store (not known because
it's not unpacked but also not known to be present in some other
remote) then this will fail because it's impossible to resolve
the files. Consider refreshing the metadata with
\link{outpack_location_pull_metadata} to refresh this.
\item if the \code{id} is not unpacked \emph{and} no local copy of the files
referred to can be found, we error by default (but see the next
option). However, sometimes the file you refer to might also be
present because you have downloaded a packet that depended on
it, or because the content of the file is unchanged because from
some other packet version you have locally.
\item if the \code{id} is not unpacked, there is no local copy of the file
and if \code{allow_remote} is \code{TRUE} we will try and request the file
from whatever remote would be selected by
\link{outpack_location_pull_packet} for this packet.
}

Note that empty directories might be created on failure.
}
